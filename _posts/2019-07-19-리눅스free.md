---
layout: post
title: "[실습과 그림으로 배우는 리눅스 구조] - free"
author: "Hongmin Park"
---
*이 글은 [[실습과 그림으로 배우는 리눅스 구조] - free](https://hongminpark.github.io/2019-07-17/Linux-top)에서 이어졌습니다.*<br><br>

이번에는 책을 바탕으로 **메모리** 관련 부분에 대해서 정리해보았다. 리눅스에서는 `free` 명령어를 통해서 현재 서버의 메모리 상황을 볼 수 있다.
[free 명령어 예시]
```console
[root@host1 ~]# free
                   total         used            free     shared    buffers     cached
Mem:        126060     123476       2584          0      41396      47364
-/+ buffers/cache:      34716      91344
Swap:       524152       1148     523004
```
*[참고] 기본은 Byte이다. `free -m`, `free -g`를 통해 Megabyte, Gigabyte단위로 확인이 가능하다.*
<br>
위와 같이 `free` 명령어를 날려보면 `total, used, free, shared, buffers, cached, swap`
까지 디테일한 메모리 정보를 알 수 있다. `total, used, free`까지는 직관적으로 이해가 되는데, 
`shared, buffers/cached, swap`는 명확히 알고있지 못했다. 
이 부분에 대해서 역시 책을 바탕으로 아래에서 정리해 볼 예정이다.

## Linux에서의 메모리
Linux 서버에서의 전체 메모리는 **커널 메모리 + (프로세스의 메모리) * N + 빈 메모리**로 표현할 수 있다. 커널 메모리는 리눅스 OS 자체에서 사용하는 메모리, 프로세스는 리눅스 위에서 동작하는 
프로그램이 사용하는 메모리, 그리고 이 둘을 제외한 부분이 빈 메모리라고 할 수 있다. 각 부분을 
위의 `free` 명령어에 매핑해보면 아래와 같다.
`total`
: 전체 메모리이다. 위 예시에서 전체 **126060**Byte, 12GB임을 알 수 있다.
`free`
: 전체영역 중 아예 사용되지 않는 메모리이다. 
`buff/chache`
: 버퍼 캐시, 페이지 캐시에 이용되는 메모리이다. 시스템의 빈 메모리=**free** 영역이 부족하면 커널이 해제를 요청하고 버퍼/캐시된 부분을 **free** 영역으로 반환하여 사용이 가능하다.
`available`
: 실질적으로 사용이 가능한 메모리이다. **free**부분이 부족하면 **buff/cache** 영역 또는 **커널메모리**의 일부가 해제되며 사용 가능한 영역이 되기 때문에 이 부분까지를 **availble** 영역으로 본다.
`swap`
: 물리메모리에 메모리 할당을 요청하였는데 부족할 경우 이 부분을 사용한다. **스왑**에 관해서는 아래에서 더 자세히 설명하겠다.

<br><br>결론은, 빠른 판단이 필요할 때에는 `free -m` 명령어에서 `available`(또는 `free` + `buff/chace`)를 보는 것이다. 

## 메모리 할당 과정
이 책에서는 메모리 할당 과정에 필요한 기술들을 순차대로 설명하고 있다. A라는 기술은 사실 C라는 기술로 이루어져 있는데 C를 설명하기 위해서는 B를 이해해야하기 때문에 설명은 B - C - A 순서로 전개된다. 

프로세스는 커널을 통해서 메모리를 할당받는다. 커널은 프로세스 생성 시와 프로세스 생성 후 프로세스가 추가 메모리 할당을 요청하면 동적으로 할당해준다. 커널은 메모리 확보용 시스템 콜을 통해 프로세스에게 빈 메모리 일부의 시작주소값을 반환하게 되는데, 이 경우에 여러 단점이 생긴다. 이를 테면, 1~1024까지 사용가능했는데, 10~300, 400~600, 700~900, 950~1024 이런 방식으로 할당이 되어있는 상태에서, 전체적으로는 10+100+100+50=260 정도가 남지만 정작 260만큼을 요청해도 메모리 사용 공간들이 쪼개져버려 사용할 수 없게 된다. 이런 현상을 [메모리단편화](https://jeong-pro.tistory.com/91)
라고 한다.(방금 설명은 매우 간략히 설명한 것으로, 자세한 설명은 위의 글에 매우 자세히 설명되어 있습니다.)
이런 단점을 해결하기 위해 커널은 **'가상메모리'**를 사용한다.

## 가상메모리
시스템 메모리의 **실제주소(real address) = 물리주소(physical address)**에 프로세스가 직접 접근하지 않고 **논리주소(logical address) = 가상주소(virtual address)**를 이용하여 간접적으로 메모리에 접근하는 방식이다. 이 때 가상주소와 물리주소가 상호 매핑되어 있는 표를 **'페이지 테이블'**이라고 하고, 가상주소와 페이지 테이블 등을 통틀어 가상메모리 방식이라고 일컫는다. <br>
*책을 보기 전까지는 swap 메모리가 가상메모리와 동일하다고 알고 있었다. swap 메모리는 물리적으로 RAM과 동일한 메모리가 아니기 때문에 가상메모리의 Concept인 것은 맞으나, 여기서 설명하고자 하는 가상메모리의 의미와는 다르다.*
<br>
프로세스는 프로그램의 실행파일을 통해 프로그램 보조정보를 읽어들이고 페이지테이블을 작성하여 가상주소와 물리주소를 매핑하게 된다. 페이지테이블을 통해 물리주소는 불연속적이지만 이를 가상주소 상에는 연속적으로 매핑할 수 있다. 즉, 메모리 단편화 문제를 해결할 수 있다. 

## 가상메모리의 응용
가상메모리는 여러 방법으로 응용 구현 되어있다.
**파일맵**
: DISK에 저장되어 있는 파일은 읽고 쓰는 작업이 메모리보다 오래 걸린다. 이를 개선하기 위해 프로세스는 파일에 접근할 때 파일을 연 뒤 `read(), write(), lseek()` 등의 시스템 콜을 사용하는데, 이 시스템 콜들은 `mmap()`을 통해 파일의 내용을 메모리로 읽어들이고 가상주소 공간에 매핑한다. 매핑한 파일은 메모리 접근과 동일하게 가상메모리의 주소를 통해 접근할 수 있다. 
**디맨드 페이징**
: 프로세스에 메모리 할당 시에 커널이 필요한 영역을 메모리에 확보한 뒤 가상공간에 물리공간을 바로 매핑하지 않고, 가상공간에 대한 메모리 요청이 들어오면 **page fault**를 발생시켜 그 때 물리메모리 공간을 매핑한다. 즉, 요청이 들어오면 그 때 매핑하는 lazy한 방식이다. 

## 스왑
어떠한 방식이든 물리메모리에 요청했는데 메모리가 부족할 경우에 발생한다. 커널은 프로세스들이 사용하고 있던 메모리 영역 중 가장 사용하지 않을 것 같은 프로세스의 메모리를 스왑영역(주로 저장장치가 스왑영역으로 설정된다.)으로 옮긴다. 이를 **swap out(page out)** 이라 한다. 시간이 흘러 물리메모리에 여유가 생기면 스왑영역의 메모리를 다시 물리 메모리로 옮기는 **swap in(page in)**과정이 일어난다. swap in, swap out과정을 **swapping(paging)** 이라고 한다.<br>
리눅스에서 스왑의 단위가 페이지이기 때문에 paging 이라고도 한다. 간혹 메모리에 접근할 때마다 swap in, swap out이 잦게 발생하는 경우가 있는데 이를 **thrashing**상태라고 하며, 물리메모리를 늘리는 것이 필요하다. `free` 명영어로는 실시간으로 swap이 일어나는것을 모니터링하기는 어려운데, `top`명령어의 상단 제일 아랫부분에서 Swap 모니터링이 가능하다. 

## 캐시
지금까지 이야기한 메모리는 우리가 흔히 생각하는 메모리인 RAM이다. 그런데 컴퓨터에는 RAM말고도 데이터를 저장하는 다양한 장치가 있다. 이를 메모리 장치의 계층으로 표현하는데 작고, 비싸고, 빠른 순서로 `레지스터 > 캐시메모리 > 메모리 > 저장장치`이다. 레지스터와 캐시메모리는 CPU영역이 속하고, 저장장치는 DISK 영역이다. 
### 캐시 메모리
컴퓨터는 크게 다음과 같은 세 가지 처리 흐름을 갖고있다.
1) 명령어를 바탕으로 메모리에서 레지스터로 데이터 읽기
2) 레지스터 데이터를 바탕으로 계산
3) 계산 결과를 메모리에 씀
<br>
CPU 작업에 있어서 중요도는 2)번이지만, 실제로는 1)과 3)에서 매우 오래걸린다고 한다. 병목인 것이다. 그럴 수 밖에 없는것이 CPU 바깥에 있는 메모리로부터 데이터를 읽어오는 과정이 단연 CPU 내부에서의 동작보다 시간이 오래걸린다. 어딘가에서 가져오는 작업이니 오래걸린다는 것이다. 이처럼 Memory에 찾아갔다 오는 시간을 줄여 latency를 줄이고자 CPU 내부에도 작은 메모리가 있다. 이를 **캐시메모리**라고한다. 일반적으로는 CPU내부에 있는데, CPU밖에 있는 캐시메모리도 있다고 한다. 캐시메모리는 L1, L2,... 와 같이 레벨로 표현되는데 낮은 레벨일 수록 레지스터에 가깝고 빠르고 용량이 작다. 

### 페이지 캐시
CPU에서 메모리 접근한 속도도 느리다고 하는데, 저장장치에 접근하는 속도는 더 빠를 리가 없다. 역시 CPU가 저장장치에 접근해 데이터를 읽어오는 속도를 높이기 위해 **'페이지 캐시'**라는 기능을 사용한다. 캐시메모리와 비슷하게 저장장치 내의 파일데이터를 메모리에 캐싱하는 것이다. 페이지 캐시 영역은 공유영역으로 모든 프로세스가 접근 가능하다. 또 캐시 사이즈는 시스템 메모리가 비어있는 한, 프로세스가 페이지 캐시에 없는 파일을 읽을 때마다 증가한다. 시스템 메모리가 부족해지면 커널이 페이지캐시를 해제하여 메로리를 반납할 수 있도록 한다. 

프로그래머스 2019 하반기 웹개발 채용에서 과제를 진행했다.<br> 
과제는 13개월 미만의 지원자를 대상으로 `Spring Boot, Django, Nodejs, Ruby On Rails`로 웹을 구현하는 것이었다. 사실 나는 13개월 이상 근무경험으로 과제대상자는 아니었는데 뒤늦게 과제를 요청했다. 과제 주제는 [캘린더](https://codepen.io/junheee/pen/vYBMrgp)를 구축하는 것이다. [코드펜](https://codepen.io/junheee/pen/vYBMrgp)에 미리 달력이 구현된 프론트엔드 코드를 주셨고, 이를 바탕으로 백엔드는 새로 구축하고 프론트는 수정해서 캘린더를 구축하는 것이었다. <br>
월요일 퇴근 후 바로 요구사항/샘플파일/프론트엔드 코드 등을 찬찬히 보았다. 과제를 진행하면서 프로그래머스에서 여러 모로 굉장히 섬세하게 과제를 만들었다는 것을 매일 매일 느꼈다.
<br><br>
잘 하는 곳은 이렇게 파이프라인을 구성한다는 것을 느낀 것만으로 과제를 참여하길 정말 잘했다는 생각을 하였다. 결론적으로 과제는 기본구현 요구사항의 60%정도밖에 완성하지 못한 것 같다. 추가 요구사항은 애초에 욕심내지 못했고, 기본 요구사항에서는 `Validation`, `Logging` 등 완성도를 높이기 위해 수정해야했던 나머지 자잘 자잘한 부분들이 아쉬웠다. 그리고 제공된 제출 툴을 사용하지 못하고 결국 `GCP`에 1시간만에 디플로이해서 링크로 제출하였다. <br><br>

## Detail Reviews
- 과제 제출을 위해 `github`에 `private`으로 레포를 구성한 후 `collaborator`에 프로그래머스 봇을 추가하면 과제 제출 플랫폼에서 제출 클릭 시 봇이 레포랑 연결되어 소스를 가져온다. 그 후에는 aws에 자동배포되는 플랫폼이 구축되어 있는 듯 했다.
- 각 웹 프레임워크별로 기본 세팅이 되어있는 소스코드를 제공해주었는데, 나는 `Spring Boot`를 선택하였다. 작년에 `Spring, Maven`을 이용한 개발경험만 있었고 `Spring Boot`는 사실 처음이었다. 그리고 샘플 세팅은 빌드 툴로 `Maven`이 아닌 `Gradle`이었는데 샘플 세팅대로 그냥 `Gradle`을 선택하였다. 
- 배포를 위한 DB Migration 툴로 `Flyway`가 샘플 프로젝트 코드 내에 삽입되어 있었다. 사실 DB Migration 툴이라는게 있는지도 처음 알았다. 마지막에 급하게 `GCP`에 구축하느라 `Flyway`를 사용하지는 못했지만 미리 작성해둔 `*.sql`파일에서 바로 테이블 생성/데이터 삽입 작업을 빠르게 끝낼 수 있었다.
- `Spring Boot`에서는 템플릿 엔진으로 `Thymeleaf`를 사용한다. 기존에 `Spring`에서는 `jsp`기반이었는데, 새로운 엔진을 사용하게 되었다. `Thymeleaf`는 기본적으로는 `html`파일에 `<div th:${event}>`와 같이 `th:`라는 템플릿 엔진 코드를 사용해서 앱 실행 시에 객체를 렌더하는 방식이다. 그래서 템플릿 코드에서 문제가 생기면 앱 기동이 안된다. 
- 제출 당일 저녁 10시쯤 처음으로 디플로이 시도를 했다. 아직 수정사항이 많았는데, 혹시나 제출을 못할까봐 한 번 미리 디플로이는 해봐야겠다 싶어서 시도했다. 나는 프로그래머스에서 시키는대로 다 했고 따로 설정을 건드린 부분은 없어서 당연히 성공할 거라고 생각했는데, 웬걸.... 실패했다. `Gradle` 빌드는 성공했고 웹서비스도 실행은 되어 접속은 됬는데 DB부분에서 Table을 못찾는 에러가 떴다. Table을 못찾는다는 것은 Table이 생성되지 않았다는 것인데.. 이 때 부터 삽질이 시작되었다.
- 결론적으로는 Ubuntu Mysql에서는 디폴트로 table이 **'Case Sensitive'**한 것 때문에 에러가 났었다. `GCP`로 배포하지 않았다면 전혀 찾지 못했을 것이다. 10시에 배포시도 후 위 에러를 맞이한 후 1시간정도 여러가지 바꿔보며 시도했는데 에러를 찾지 못했다. 빌드 툴을 직접 사용하는게 아니라서 어느 부분에서 에러가 발생한 것인지 찾을 수가 없을 것 같아 빠르게 클라우드 호스팅을 사용해야겠다고 결정했고, 최근에 사용한 `GCP`에 `GCE`를 생성했다.
- 이걸 1시간만에 할 수 있을까 싶다가도 소스받아오고, db설치/세팅하고, 빌드 후 실행 스텝만 거치면 되니까 할 수는 있겠다 싶었다. ~~(물론 예상치못한 문제를 만나서 제출 못할 수도 있겠다는 우려도 반 정도 하였다.)~~
- 먼저 `git clone`으로 소스를 받아왔다. 그리고 [CentOS7에 Mysql8 설치하기](https://tecadmin.net/install-mysql-8-on-centos/) 가이드를 참고해서 db를 설치했다. 테이블을 생성하고 데이터를 삽입한 후 얼른 빌드를 시도했다. 그래들 명령어도 직접 커맨드에서 친 적은 없어서 긴가민가 하며 여러 명령어를 날려보았다. 소스 경로에서 `./gradlew build`를 날리니 빌드 후 jar를 생성해주었고 `~/build/libs` 경로에 jar파일이 생성되었고, `java -jar ~~.jar`로 Spring Boot 앱을 바로 띄울 수 있었다.
- `GCP`로 결정 후 앱을 띄우기까지는 생각보다 얼마 안걸렸다. 제출까지 30~40분정도는 남았던 것 같았다. 
`GCE`에서 5000포트를 http inbound 포트로 열어준 후 접속을 했는데.. 에러페이지가 떴다. 이럴리가 없는데.. 하고 로그를 보니 아까 프로그래머스에서 디플로이 후와 동일한 테이블을 못찾는 에러가 떴다. 여러방법으로 테이블 재생성을 해보니 대소문자 구별이 원인이었다. 현재 소스에서 DB생성은 `CREATE TABLE Event () ~~~`와 같이 `Event`라는 테이블을 생성하고, CRUD작업을 하는 Sql문에서는 `SELECT * FROM event`와 같이 `event`로 호출하고있었다. 이 소스로 내 로컬(Mac)에서는 동작하였고, 기존에 case insensetive라고 인지하고 있어서 괜찮을 거라고 생각했다. 그런데 `CentOS`에 설치한 mysql에서는 기본으로 **case sensitive**였던 것이다. 뒤늦게라고 에러를 발견했고 이것 저것 수정 후 겨우 과제를 제출할 수 있었다. 
- 추가적인 수정 부분을 반영해서 4~5 차례의 추가 재배포 이후에 11시 50분쯤 과제를 마무리하였다. 녹초가 되어 버스를 타고 집으로 왔다.
<br><br>

## 결론
평가자가 어떻게 평가를 내리든 값진 경험이었다. 물론 남들보다 많이 부족하겠지만, 세상에 이런 툴/방법도 있다는걸 알았고 단시간에 `Spring Boot, Gradle, Thymeleaf`로 웹을 만드는 경험을 했다. 최근에 `java`를 사용할 일이 몇 번 있었는데, `java`공부를 해야겠다고 느꼈다. 엔지니어 영역에서는 개발을 잘 안하다 보니 사실 만들 수는 있지만 언어의 특성을 바르게 이해하고 만들지는 못했다. 이번에 웹을 만들면서 다시 `public, private, static, ...` 등 `java` 공부를 다시 해야겠다고 느꼈다. 









