---
layout: post
title: "객체지향이란"
author: "Hongmin Park"
---
파이썬에서는 .py 파일에 `def main()`하나만 있으면 되는데, 자바에서는 `public static void main(String[] args)`과 같이 Class를 생성하고 main함수 작성을 위해 앞에 달린 수많은 수식어구들 때문에 자바에 대한 거부감이 컸다. 도대체 자바는 뭐가 저렇게 많이 필요할까 싶었다. 최근 파이썬으로만 풀던 알고리즘 문제를 자바로 풀어보고, Spring Boot로 오랜만에 간단한 웹개발을 하면서 어차피 잘 만든 프로그램은 Java든 Python이든 올바르게 구조화되어있어야 한다고 느꼈다. 그리고 자바의 `public static void`와 같은 수식어구는 구조화를 잘 하기 위해 도와주는 것이라는 생각이 들었다. 자바로 객체지향, 디자인패턴 등을 공부해야겠다고 느꼈다. 일단, 최근에 정리되지 않았던 객체화에 대한 개념과 public static void와 같은 수식어구를 ['스프링 입문을 위한 자바 객체지향의 원리와 이해'](http://book.interpark.com/product/BookDisplay.do?_method=detail&sc.prdNo=237559903&gclid=Cj0KCQjwivbsBRDsARIsADyISJ-wgIxfw6kbliBapVM2UFu6oRs7K8iUwhMEu37h-bVYqfjPbnR1ysgaAtymEALw_wcB) 책을 바탕으로 객체지향에 대해 정리해보겠다. 작년에 읽은 책인데, 직관적이고 통찰력있는 설명이 담겨있었다. 다만, 내가 자바를 자주 사용하지 않아서 다 잊어버렸다. 

# 프로그램이 메모리를 사용하는 방식
하나의 프로그램에서 메모리는 아래처럼 두 부분으로 나뉘어 사용된다. <br>
<table>
    <tr>
        <td>코드 실행 영역</td>
        <td>데이터 저장 영역</td>
    </tr>
</table>

거의 모든 프로그래밍 언어의 공통된 메모리 사용 방식이다. 객체지향 프로그램에서는 '데이터 저장 영역'을 다시 아래와 같이 **스태틱 영역 + 스택 영역 + 힙 영역**으로 나누어 사용한다. 이 영역은 **T메모리**라고도 한다.<br>
<table>
    <tr>
        <td rowspan="2" style="vertical-align: middle">코드 실행 영역</td>
        <td colspan="2">스태틱 영역 - class</td>
    </tr>
    <tr>
        <td>스택 영역 - method</td>
        <td>힙 영역 - object</td>
    </tr>
</table>

### 스태틱 영역
스태틱 영역에는 개발자가 작성한 모든 클래스와 import된 모든 패키지들이 들어가는 영역이다.
### 스택 영역
클래스의 method들이 존재하는 영역이다. 클래스에서 중괄호를 만날 때마다 스택영역에 스택프레임이 생긴다. 하나의 스택 프레임 내부에는 또 다른 스택 프레임이 들어갈 수 있다. 예를 들어 a 메서드 내에 if문에 있다면 스택영역에 a 스택 프레임이 생기고, a 스택 프레임 내에 if 스택 프레임이 생긴다. 스택 프레임 내에는 각 스택에서 사용하는 변수에 대한 공간도 있다. <br>
### 힙영역
힙 영역에는 클래스의 인스턴스가 존재한다. 클래스는 스태틱 영역에 존재하지만, 클래스를 바탕으로 생성된 객체(=클래스의 인스턴스)와 객체의 변수들은 힙 영역 내에 위치한다. 힙 영역 내에 있는 객체를 스태틱 영역에서 참조할 때에는 `Call by Reference`방식으로 힙 영역에 있는 객체의 주소를 참조하게 된다. 만약 모든 클래스의 인스턴스들이 동일한 값을 가지는 변수가 있다면, 힙영역에서 객체마다 변수를 저장하는 것이 아니라 `public static int days = 365;`와 같이 **Class에 속한 static 변수**로 생성해야 한다. 변수 뿐만 아니라 메서드의 경우에도, Class에 속하는 method는 static을 붙여준다. 여기서 static 변수는 익숙한데, static method는 좀 익숙하지 않았다. 책에서 말하는 바에 따르면 **정적 메서드**는 객체들의 존재 여부와 관계없이 쓸 수 있는 메서드이다. 실무에서는 **클래스의 인스턴스를 생성하지 않고** 바로 사용할 **유틸리티성 메서드** 라고 생각하면 된다. 예를들어 Math class에는 static method들이 굉장히 많다.
### 변수
각 영역 모두에서 변수는 존재할 수 있다. 메모리에 존재하는 위치에 따라 이름이 결정된다.<br>
<table>
    <tr>
        <td>static 영역</td>
        <td>클래스 멤버 변수</td>
    </tr>
    <tr>
        <td>stack 영역</td>
        <td>지역 변수</td>
    </tr>
    <tr>
        <td>heap 영역</td>
        <td>객체(인스턴스) 멤버 변수</td>
    </tr>
</table>
각 변수들은 각 영역이 살아있는 동안 사용가능하다. 예를 들어, a 메서드 내의 `for`문 내에 있는 `i`라는 변수는, 스택영역 > a 스택 프레임 > for 스택 프레임 내에서만 사용 가능한 변수이다. 그리고 for문이 끝나면 스택 프레임이 사라지고 i 변수도 사라지게 된다. 또, 메서드 안에서 다른 메서들을 호출할 때에는 독립적인 스택 프레임이 생성된다. 즉, 메서드들 간에는 parameter와 return값만 주고받을 수 있고, 그 내부의 지역변수들은 기본적으로는 공유할 수 없다. <br>
한편, **static**영역에 있는 스태틱 변수는 JVM이 종료될 때 까지 계속 살아있다. 그리고, **heap** 영역에 있는 객체 멤버 변수들은 객체가 GC될 때 같이 사라지게 된다.<br>
만약, 메서드들 간에 공유해야하는 변수라면 클래스에 `public static int a;`와 같이 정의하여 **static**영역에 변수를 저장하고 스택 영역이나 힙 영역에서 `a`라는 변수를 공유해서 사용할 수 있다. 이런 변수를 **'전역변수'**라고 한다. 하지만 되도록 지역변수를 사용하여 객체, 메서드 간에 의존관계를 줄이는 것이 좋다. 전역변수를 사용하는 것은 객체지향에서 권고하지는 않는데, 읽기 전용 상수(예, pi)와 같은 값은 전역변수로 설정해도 괜찮다. 

# 멀티쓰레드/멀티프로세스에서의 T메모리
**멀티 쓰레드**에서는 T메모리 중 **스택영역**을 스레드 개수만큼 나누어 사용한다. 즉, thread끼리 독립된 스태틱 영역을 제공한다. 단, 스태틱 영역과 힙영역은 공유해서 사용한다. Spring에서는 이것을 이용해서 쓰레드간 공유가 가능한 변수 등은 static 영역에, 그렇지 않은 것은 각 쓰레드의 stack영역에 두게 된다. 이와는 반대로 **멀티 프로세스**에서는 각 T메모리 영역 전체가 아예 분리되어 있다.<br>
<table>
    <tr>
        <td colspan="3" style="text-align: center;">스태틱 영역</td>
    </tr>
    <tr>
        <td colspan="3" style="text-align: center;">스택 영역</td>
        <td rowspan="2" style="vertical-align: middle;">힙 영역</td>
    </tr>
    <tr>
        <td>thread1</td>
        <td>thread2</td>
    </tr>
</table>
*(Servelet은 각 요청당 thread를 통해 처리하고, CGI는 각 요청당 process를 통해 처리한다.)*
<br>
멀티스레드에서는 스택영역만을 분리해서 사용하기 때문에 멀티스레드 프로그램에서 **전역변수 사용을 조심**해야 한다. A쓰레드에서 전역변수를 사용하고 변경하였다면, B쓰레드에서는 변경된 전역변수를 사용하게 된다. 이 점을 유의해야 한다.
<br><br>
지금까지 프로그램/자바에서 메모리를 사용하는 구조에 대해 살펴보았는데, 이는 객체지향을 이해하는데에 큰 도움이 된다.

# 객체
객체라는 것을 정의를 통해 이해하기는 어려운 것 같다. [Wikipedia의 정의](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))를 참고하면, 
> 컴퓨터 과학에서 객체 또는 오브젝트(object)는 저장공간에서 할당되어 값을 가지거나 식별자에 의해 참조되는 공간을 의미하며, 변수, 자료 구조, 함수 또는 메소드가 될 수 있다. 프로그래밍 언어는 변수를 이용해 객체에 접근하므로 객체와 변수라는 용어는 종종 함께 사용된다. 그러나 메모리가 할당되기 전까지 객체는 존재하지 않는다.
> 객체지향 프로그래밍에서 객체는 클래스의 인스턴스이다. 클래스 객체는 자료와 그 자료를 다루는 명령의 조합을 포함하여 객체가 메시지를 받고 자료를 처리하며 메시지를 다른 객체로 보낼 수 있도록 한다. 

즉, 클래스를 바탕으로 누군가 인스턴스를 생성했을 때 그 인스턴스를 객체라고 한다. 

## 객체지향의 4대 특성
클래스와 객체(인스턴스)의 개념은 '붕어빵틀 : 붕어빵' 이라기 보다는, '강아지 : 초롱이'같은 느낌이다. 클래스는 분류에 대한 개념이고, 그 분류에 속하는 것 중 실체하는 것 하나가 객체이다. 이를 바탕으로 객체지향의 4대 특성을 이해해보자.

### 1. 캡슐화, Encapsulation

객체지향에서 캡슐은 '1) 객체의 속성과 행위를 하나(클래스)로 묶고, 2)구현 내용의 일부는 외부로부터 노출되지 않도록 한다'는 측면을 뜻한다. '1)'번 속성은 밑에서 설명할 상속, 추상화, 다형성 전체와도 관련이 있는 특성이고 여기서는 '2)'번 측면에 대해서 집중하겠다. 2)에 다르면 캡슐화는 클래스 내부에 구현된 부분를 외부로부터 감추는=**은닉**하는 것이다. 이렇게 객체의 내부로직을 감추면 접근할 수 있는 부분이 제한되고 다른 클래스와의 **결합도가 낮아지는** 장점이 있다. 결합도가 낮다는 것은, 코드의 변경에 유연하게 대처할 수 있다는 것을 뜻한다. 감추는 정도는 **'접근제어자'**인 `public, protected, private`을 통해 구현한다. 간단히 요약하면 각각은 아래와 같은 경우를 의미하는 접근제어자이다.
>**public**: 모두 접근 가능
**protected**: 상속된 클래스나 같은 패키지 내의 클래스 접근 가능 
**[default]**: 같은 패키지 내의 클래스에서 접근 가능
**private**: 자기 자신에서만 접근 가능 

~~(위와 같다고는 하는데, 캡슐화에 대한 부분은 직접 코드를 구현할 때에 많이 고민이 되는 부분이고 아직 이해가 잘 가지 않은 것 같다. 언젠가 다시 정리가 필요해 보인다.)~~

### 2. 상속, ~~Inheritance~~ Extension

객체지향에서 상속은 하위 클래스가 상위 클래스의 속성을 갖는 것이다. '부모-자식' 이라기 보다는 '동물-인간'과 같이 '상위분류-하위분류'와 같은 개념에 더 가깝다. 인간은 동물이라는 클래스를 상속한 것이라고 할 수 있다. 즉, 상속은 **상위 클래스의 특성을 재사용/확장**한 것이다.<br>
한면, Java에서는 다중상속을 지원하지 않는 대신 `Interface`라는 것을 도입하였다. 특정 Interface를 implements했다는 것은, 그 Interface가 갖는 속성이 가능하도록 구현했다는 것이다. 예를들면 `Serializable, Cloneable, Comparable, Runnable`과 같은 인터페이스가 있다. 인터페이스는 `be able to`로 새로운 특성을 강제하도록 구현한다. 예를들어 `public class A extends B implements C`라는 것은 'A 클래스는 상위클래스인 B의 특성을 모두 가지고 있으면서, C가 갖고있는 특성을 추가적으로 갖고있다' 정도의 개념으로 이해할 수 있다.<br>
한편, 하위클래스의 인스턴스가 생길 때 T메모리의 힙영역에는 하위클래스 객체만 생기는 것이 아니라 **상위클래스 인스턴스도 생긴다**. 이것이 중요한 경우는 아래와 같은 경우이다. 
```java
Animal pingu = new Penguin();
Penguin pororo = new Penguin();
```
위와 같이 pingu와 pororo를 생성했을 때, pingu, pororo 인스턴스를 만들 때에 각각 Penguin과 그 상위 클래스인 Animal의 인스턴스 모두 생성이 된다. 그런데, pingu의 자료형이 Penguin이 아닌 Animal이기 때문에 pingu는 Penguin 인스턴스가 갖고 있는 변수나 메소드는 사용하지 못하게 된다. 

### 3. 추상화, Abstraction

추상화는 공통적인 부분을 추출해내는 것이다. 사람1, 사람2, ... 가 있을 때 이들의 공통점을 찾아 '사람'이라는 클래스를 만드는 것이다. 즉, Class를 새성할 때에는 이것의 실체(클래스의 인스턴스=객체)를 생각하고, 그 실체들의 공통점을 잘 추출(=모델링)하여 Class로 만들어야한다. **추상화 = 모델링**이다. 그리고 자바에서는 객체지향 중 추상화를 **'class'**로 지원하고 있다.

### 4. 다형성, Polymorphism

다형성은 **오버라이딩, 오버로딩**을 통해 하위 클래스가 상위 클래스의 함수를 변형할 수 있도록 한다. 오버라이딩은 상위클래스의 메서드를 완전히 새로 정의하는 것이고, 오버로딩은 상위클래스의 메서드를 인자만 다르게 하여 여러 개 정의하는 것이다. 예를 들어, 메서드 명은 하나인데 인자 값을 받는 경우도 있고 안 받는 경우도 있는 시스템함수와 같은 것들이다. <br>
하위클래스가 상위클래스의 메서드를 오버라이딩 했을 경우, T메모리에서 상위 클래스 인스턴스의 메소드는 하위 클래스가 오버라이딩한 메소드로 덮어 씌워진다. 그래서 아래 코드와 같이 상위클래스로 정의한 객체가 하위클래스의 인스턴스를 참조할 때에 오버라이딩된 메서드를 사용할 수 있게된다. 
```java
Animal[] animals = new Animal[2];
animals[0] = new Cat();
animals[1] = new Rabbit();
for (Animal animal: animals) animal.cry();
```
다형성을 통해 **구현의 유연함**, **사용 편의성**을 제공해주는 것이라고 이해하자.


